                    
                    
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ 18 Code Findings â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                                
  [36m[22m[24m  pcs/config.py[0m
   â¯â¯â± [1mtrailofbits.python.tarfile-extractall-traversal.tarfile-extractall-traversal[0m
          Possible path traversal through `tarfile.open($PATH).extractall()` if the source tar is controlled
          by an attacker                                                                                    
          Details: https://sg.run/2RLD                                                                      
                                                                                                            
          351â”† tarball = tarfile.open(infile_name, "r|*", infile_obj)
          352â”† while True:
          353â”†     # next(tarball) does not work in python2.6
          354â”†     tar_member_info = tarball.next()
          355â”†     if tar_member_info is None:
          356â”†         break
          357â”†     if tar_member_info.name == "version.txt":
          358â”†         version_data = tarball.extractfile(tar_member_info)
          359â”†         version = version_data.read()
          360â”†         version_data.close()
             [hid 41 additional lines, adjust with --max-lines-per-finding] 
          381â”† tarball = tarfile.open(infile_name, "r|*", infile_obj)
          382â”† while True:
          383â”†     # next(tarball) does not work in python2.6
          384â”†     tar_member_info = tarball.next()
          385â”†     if tar_member_info is None:
          386â”†         break
          387â”†     extract_info = None
          388â”†     path = tar_member_info.name
          389â”†     while path:
          390â”†         if path in file_list:
             [hid 11 additional lines, adjust with --max-lines-per-finding] 
                              
  [36m[22m[24m  pcs/pcsd.py[0m
    â¯â± [1mpython.lang.security.audit.insecure-file-permissions.insecure-file-permissions[0m
          These permissions `0o700` are widely permissive and grant access to more people than may be       
          necessary. A good default is `0o644` which gives read and write access to yourself and read access
          to everyone else.                                                                                 
          Details: https://sg.run/AXY4                                                                      
                                                                                                            
           62â”† os.chmod(settings.pcsd_cert_location, 0o700)
            â‹®â”†----------------------------------------
           67â”† os.chmod(settings.pcsd_key_location, 0o700)
                                  
  [36m[22m[24m  pcsd/cfgsync.rb[0m
    â¯â± [1mruby.lang.security.weak-hashes-sha1.weak-hashes-sha1[0m
          Should not use SHA1 to generate hashes. There is a proven SHA1 hash collision by Google, which could
          lead to vulnerabilities. Use SHA256, SHA3 or other hashing functions instead.                       
          Details: https://sg.run/e4qX                                                                        
                                                                                                              
          182â”† return Digest::SHA1.hexdigest(self.text || '')
                                         
  [36m[22m[24m  pcsd/cluster_entity.rb[0m
   â¯â¯â± [1mruby.lang.security.model-attributes-attr-accessible.model-attributes-attr-accessible[0m
          Checks for models that do not use attr_accessible. This means there is no limiting of which        
          variables can be manipulated through mass assignment. For newer Rails applications, parameters     
          should be allowlisted using strong parameters. For older Rails versions, they should be allowlisted
          using strong_attributes.                                                                           
          Details: https://sg.run/1nrb                                                                       
                                                                                                             
          486â”† class Primitive < Resource
            â‹®â”†----------------------------------------
          679â”† class Group < Resource
                              
  [36m[22m[24m  pcsd/pcs.rb[0m
    â¯â± [1mruby.rails.security.injection.tainted-url-host.tainted-url-host[0m
          User data flows into the host portion of this manually-constructed URL. This could allow an attacker
          to send data to their own server, potentially exposing sensitive data such as cookies or            
          authorization information sent with this request. They could also probe internal servers or other   
          resources that the server runnig this code can access. (This is called server-side request forgery, 
          or SSRF.) Do not allow arbitrary hosts. Use the `ssrf_filter` gem and guard the url construction    
          with `SsrfFilter(...)`, or create an allowlist for approved hosts.                                  
          Details: https://sg.run/RX3g                                                                        
                                                                                                              
          446â”† url = "https://#{node6}:2224/remote/#{request}"
            â‹®â”†----------------------------------------
          448â”† url = "https://#{node6}:2224/#{request}"
                                                      
  [36m[22m[24m  pcsd/public/js/handlebars-v1.2.1.js[0m
    â¯â± [1mjavascript.lang.security.audit.incomplete-sanitization.incomplete-sanitization[0m
          `param.replace` method will only replace the first occurrence when used with a string argument 
          ("\n"). If this method is used for escaping of dangerous data then there is a possibility for a
          bypass. Try to use sanitization library instead or use a Regex with a global flag.             
          Details: https://sg.run/1GbQ                                                                   
                                                                                                         
          2124â”† param = "\"" + param.replace("\n", "\\n") + "\"";
                              
  [36m[22m[24m  pcsd/ssl.rb[0m
    â¯â± [1mruby.lang.security.ssl-mode-no-verify.ssl-mode-no-verify[0m
          Detected SSL that will accept an unverified connection. This makes the connections susceptible to
          man-in-the-middle attacks. Use 'OpenSSL::SSL::VERIFY_PEER' instead.                              
          Details: https://sg.run/kLxX                                                                     
                                                                                                           
           [32mâ–¶â–¶â”† Autofix â–¶ [0mOpenSSL::SSL::VERIFY_PEER
          138â”† :SSLVerifyClient    => OpenSSL::SSL::VERIFY_NONE,
                                                      
  [36m[22m[24m  pcsd/views/_permissions_cluster.erb[0m
    â¯â± [1mruby.rails.security.audit.xss.templates.var-in-script-tag.var-in-script-tag[0m
          Detected a template variable used in a script tag. Although template variables are HTML escaped,    
          HTML escaping does not always prevent cross-site scripting (XSS) attacks when used directly in      
          JavaScript. If you need to do this, use `escape_javascript` or its alias, `j`. However, this will   
          not protect from XSS in all circumstances; see the references for more information. Consider placing
          this value in the HTML portion (outside of a script tag).                                           
          Details: https://sg.run/58r6                                                                        
                                                                                                              
           14â”† permissions_dependencies["<%= h(@cluster_name) %>"] = {};
            â‹®â”†----------------------------------------
           27â”† permissions_dependencies["<%= h(@cluster_name) %>"] = <%= @permissions_dependencies.to_json
               %>;                                                                                        
            â‹®â”†----------------------------------------
           27â”† permissions_dependencies["<%= h(@cluster_name) %>"] = <%= @permissions_dependencies.to_json
               %>;                                                                                        
                                           
  [36m[22m[24m  pcsd/views/_resource.erb[0m
    â¯â± [1mruby.rails.security.audit.xss.templates.unquoted-attribute.unquoted-attribute[0m
          Detected a unquoted template variable as an attribute. If unquoted, a malicious actor could inject 
          custom JavaScript handlers. To fix this, add quotes around the template expression, like this: "<%=
          expr %>".                                                                                          
          Details: https://sg.run/PpeN                                                                       
                                                                                                             
           65â”† <%= "selected" if cp == "ocf:heartbeat" %>
            â‹®â”†----------------------------------------
          101â”† <option width=250px <%= @stonith_agents[name]["type"] == "fence_apc" ? "selected" : "" %>  
               value="stonith:<%=@stonith_agents[name]["type"]%>"><%=@stonith_agents[name]["type"]%></opti
               on>                                                                                        
                                       
  [36m[22m[24m  pcsd/views/login.erb[0m
    â¯â± [1mruby.rails.security.audit.xss.templates.unquoted-attribute.unquoted-attribute[0m
          Detected a unquoted template variable as an attribute. If unquoted, a malicious actor could inject 
          custom JavaScript handlers. To fix this, add quotes around the template expression, like this: "<%=
          expr %>".                                                                                          
          Details: https://sg.run/PpeN                                                                       
                                                                                                             
           10â”† <input type="text" name="username" <%=
           11â”†   "value='#{h(session[:bad_login_name])}'" if session[:bad_login_name]
           12â”† %>>
                                      
  [36m[22m[24m  pcsd/views/main.erb[0m
    â¯â± [1mruby.rails.security.audit.xss.templates.var-in-href.var-in-href[0m
          Detected a template variable used in an anchor tag with the 'href' attribute. This allows a       
          malicious actor to input the 'javascript:' URI and is subject to cross- site scripting (XSS)      
          attacks. If using a relative URL, start with a literal forward slash and concatenate the URL, like
          this: href='/<%= link =>'. You may also consider setting the Content Security Policy (CSP) header.
          Details: https://sg.run/J3Do                                                                      
                                                                                                            
          1185â”† <a href="<%=c.ui_address%>" class="menu-item"><%=c.name%>&nbsp;&nbsp;</a>
