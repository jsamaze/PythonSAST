                    
                    
‚îå‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îê
‚îÇ 16 Code Findings ‚îÇ
‚îî‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îò
                                         
  [36m[22m[24m  benchmark/benchbase.py[0m
    ‚ùØ‚ù± [1mpython.lang.security.audit.exec-detected.exec-detected[0m
          Detected the use of exec(). exec() can be dangerous if used to evaluate dynamic content. If this 
          content can be input from outside the program, this may be a code injection vulnerability. Ensure
          evaluated content is not definable by external sources.                                          
          Details: https://sg.run/ndRX                                                                     
                                                                                                           
           12‚îÜ exec(code, glob)
                                 
  [36m[22m[24m  buildlibxml.py[0m
    ‚ùØ‚ù± [1mpython.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected[0m
          Detected a dynamic value being used with urllib. urllib supports 'file://' schemes, so a dynamic    
          value controlled by a malicious actor may allow them to read arbitrary files. Audit uses of urllib  
          calls to ensure user data cannot control the URLs, or consider using the 'requests' library instead.
          Details: https://sg.run/dKZZ                                                                        
                                                                                                              
           64‚îÜ urlretrieve(srcfile, destfile)
   
    ‚ùØ‚ù± [1mpython.lang.security.audit.ftplib.ftplib[0m
          FTP does not encrypt communications by default. This can lead to sensitive data being exposed.
          Ensure use of FTP here does not expose sensitive data.                                        
          Details: https://sg.run/7oyZ                                                                  
                                                                                                        
          146‚îÜ ftp = FTP(parts.netloc)
   
    ‚ùØ‚ù± [1mpython.lang.security.audit.insecure-transport.ftplib.use-ftp-tls.use-ftp-tls[0m
          The 'FTP' class sends information unencrypted. Consider using the 'FTP_TLS' class instead.
          Details: https://sg.run/AvPp                                                              
                                                                                                    
           [32m‚ñ∂‚ñ∂‚îÜ Autofix ‚ñ∂ [0mFTP_TLS(parts.netloc, context=ssl.create_default_context())
          146‚îÜ ftp = FTP(parts.netloc)
   
    ‚ùØ‚ù± [1mpython.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected[0m
          Detected a dynamic value being used with urllib. urllib supports 'file://' schemes, so a dynamic    
          value controlled by a malicious actor may allow them to read arbitrary files. Audit uses of urllib  
          calls to ensure user data cannot control the URLs, or consider using the 'requests' library instead.
          Details: https://sg.run/dKZZ                                                                        
                                                                                                              
          158‚îÜ with closing(urlopen(url)) as res:
            ‚ãÆ‚îÜ----------------------------------------
          172‚îÜ with closing(urlopen(url)) as res:
            ‚ãÆ‚îÜ----------------------------------------
          291‚îÜ urlretrieve(full_url, dest_filename)
   
   ‚ùØ‚ùØ‚ù± [1mtrailofbits.python.tarfile-extractall-traversal.tarfile-extractall-traversal[0m
          Possible path traversal through `tarfile.open($PATH).extractall()` if the source tar is controlled
          by an attacker                                                                                    
          Details: https://sg.run/2RLD                                                                      
                                                                                                            
          297‚îÜ tar = tarfile.open(tar_filename)
          298‚îÜ base_dir = None
          299‚îÜ for member in tar:
          300‚îÜ     base_name = member.name.split('/')[0]
          301‚îÜ     if base_dir is None:
          302‚îÜ         base_dir = base_name
          303‚îÜ     elif base_dir != base_name:
          304‚îÜ         print('Unexpected path in %s: %s' % (tar_filename, base_name))
          305‚îÜ tar.extractall(dest)
                                
  [36m[22m[24m  doc/mkhtml.py[0m
   ‚ùØ‚ùØ‚ù± [1mpython.lang.security.audit.subprocess-shell-true.subprocess-shell-true[0m
          Found 'subprocess' function 'call' with 'shell=True'. This is dangerous because this call will spawn
          the command using a shell process. Doing so propagates current shell settings and variables, which  
          makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.          
          Details: https://sg.run/J92w                                                                        
                                                                                                              
           [32m‚ñ∂‚ñ∂‚îÜ Autofix ‚ñ∂ [0msubprocess.call(command, shell=False)
          150‚îÜ subprocess.call(command, shell=True)
                                              
  [36m[22m[24m  doc/s5/ui/default/slides.js[0m
    ‚ùØ‚ù± [1mjavascript.lang.security.audit.detect-non-literal-regexp.detect-non-literal-regexp[0m
          RegExp() called with a `className` function argument, this might allow an attacker to cause a       
          Regular Expression Denial-of-Service (ReDoS) within your application as RegExP blocks the main      
          thread. For this reason, it is recommended to use hardcoded regexes instead. If your regex is run on
          user-controlled input, consider performing input validation or use a regex checking/sanitization    
          library such as https://www.npmjs.com/package/recheck to verify that the regex does not appear      
          vulnerable to ReDoS.                                                                                
          Details: https://sg.run/gr65                                                                        
                                                                                                              
           32‚îÜ object.className = object.className.replace(new RegExp('(^|\\s)'+className+'(\\s|$)'),
               RegExp.$1+RegExp.$2);                                                                 
   
   ‚ùØ‚ùØ‚ù± [1mjavascript.browser.security.insecure-document-method.insecure-document-method[0m
          User controlled data in methods like `innerHTML`, `outerHTML` or `document.write` is an anti-pattern
          that can lead to XSS vulnerabilities                                                                
          Details: https://sg.run/LwA9                                                                        
                                                                                                              
          109‚îÜ cs.innerHTML = '<span id="csHere">' + snum + '<\/span> ' +
          110‚îÜ    '<span id="csSep">\/<\/span> ' +
          111‚îÜ    '<span id="csTotal">' + (smax-1) + '<\/span>';
            ‚ãÆ‚îÜ----------------------------------------
          384‚îÜ controlsDiv.innerHTML = '<form action="#" id="controlForm"' + hideDiv + '>' +
          385‚îÜ '<div id="navLinks">' +
          386‚îÜ '<a accesskey="t" id="toggle" href="javascript:toggle();">&#216;<\/a>' +
          387‚îÜ '<a accesskey="z" id="prev" href="javascript:go(-1);">&laquo;<\/a>' +
          388‚îÜ '<a accesskey="x" id="next" href="javascript:go(1);">&raquo;<\/a>' +
          389‚îÜ '<div id="navList"' + hideList + '><select id="jumplist"
               onchange="go(\'j\');"><\/select><\/div>' +              
          390‚îÜ '<\/div><\/form>';
                               
  [36m[22m[24m  setupinfo.py[0m
   ‚ùØ‚ùØ‚ù± [1mpython.lang.security.audit.subprocess-shell-true.subprocess-shell-true[0m
          Found 'subprocess' function 'Popen' with 'shell=True'. This is dangerous because this call will   
          spawn the command using a shell process. Doing so propagates current shell settings and variables,
          which makes it much easier for a malicious actor to execute commands. Use 'shell=False' instead.  
          Details: https://sg.run/J92w                                                                      
                                                                                                            
           [32m‚ñ∂‚ñ∂‚îÜ Autofix ‚ñ∂ [0msubprocess.Popen(cmd, shell=False,stdout=subprocess.PIPE, stderr=subprocess.PIPE)
          365‚îÜ p = subprocess.Popen(cmd, shell=True,
          366‚îÜ                      stdout=subprocess.PIPE, stderr=subprocess.PIPE)
                                             
  [36m[22m[24m  src/lxml/ElementInclude.py[0m
    ‚ùØ‚ù± [1mpython.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected[0m
          Detected a dynamic value being used with urllib. urllib supports 'file://' schemes, so a dynamic    
          value controlled by a malicious actor may allow them to read arbitrary files. Audit uses of urllib  
          calls to ensure user data cannot control the URLs, or consider using the 'requests' library instead.
          Details: https://sg.run/dKZZ                                                                        
                                                                                                              
          108‚îÜ f = urlopen(href)
                                            
  [36m[22m[24m  src/lxml/html/__init__.py[0m
    ‚ùØ‚ù± [1mpython.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected[0m
          Detected a dynamic value being used with urllib. urllib supports 'file://' schemes, so a dynamic    
          value controlled by a malicious actor may allow them to read arbitrary files. Audit uses of urllib  
          calls to ensure user data cannot control the URLs, or consider using the 'requests' library instead.
          Details: https://sg.run/dKZZ                                                                        
                                                                                                              
          1142‚îÜ return urlopen(url, data)
                                               
  [36m[22m[24m  src/lxml/html/html5parser.py[0m
    ‚ùØ‚ù± [1mpython.lang.security.audit.dynamic-urllib-use-detected.dynamic-urllib-use-detected[0m
          Detected a dynamic value being used with urllib. urllib supports 'file://' schemes, so a dynamic    
          value controlled by a malicious actor may allow them to read arbitrary files. Audit uses of urllib  
          calls to ensure user data cannot control the URLs, or consider using the 'requests' library instead.
          Details: https://sg.run/dKZZ                                                                        
                                                                                                              
          230‚îÜ fp = urlopen(filename_url_or_file)
